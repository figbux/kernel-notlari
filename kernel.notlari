------------------------[ Kernel Exploitation Notları ]-------------------------

    1  Önsöz
    2  Amaç
    3  Kaynakları edinin
    4  Lab ortamı kurulumu
    5  CTF'ler
    6  Kernel ne işe yarıyor?
        6.1  Kernel map
        6.2  Kernel 5.8'in codebase'ini biraz incelersek:
    7  Ring goygoyu
    8  Kernel Exploitation Temelleri
        8.1  Basit exploitation stratejisi - Büyük resim:
        8.2  Kernel'de nasıl zafiyetler var?
        8.3  Bu zafiyetleri nasıl sömürülür?
        8.4  Bazı kernel güvenlik önlemleri ve aşma yöntemleri
        8.5  Debugging
        8.6  Nerelerde zafiyetler var?
            8.6.1  LKM (Loadable Kernel Module)
                8.6.1.1  LKM'lerin kullanım alanları:
                8.6.1.2  LKM dosya yapısı
                8.6.1.3  LKM'lerle çalışmak için komutlar
    9  Proc cheatsheet
    10  Önemli kernel yapıları, fonksiyonlar vs. kernel v5.8 için sunulmuştur 
        10.1  task_struct: "işlem"in tanımı
        10.2  cred struct: işlemin yetkilerinin tanımı
            10.2.1  "current" makrosu: o anki koşan işleme pointer
        10.3  file, fdtable, files_struct: dosyalar
        10.4  Virtual function table (vft) yaklaşımı
        10.5  socket, sock, skb: ağ
        10.6  netlink_sock: IPC için özel soket
        10.7  Hepsi bir arada: current, task_struct, files_struct, fdtable,
        10.8  Reference counter kavramı
        10.9  Understanding page fault trace
    11  Kernel'in bellek yönetimi
        11.1  List of address types used in Linux
            11.1.1  User virtual addresses
            11.1.2  Physical addresses
            11.1.3  Bus addresses
            11.1.4  Kernel logical addresses
            11.1.5  Kernel virtual addresses
        11.2  High and Low Memory
            11.2.1  Low memory
            11.2.2  High memory
        11.3  Page Tables
        11.4  Virtual Memory Areas
        11.5  The mmap Device Operation
        11.6  Allocators
            11.6.1  Zoned page frame allocator (buddy allocator)
            11.6.2  Slab allocators
            11.6.3  İsimlendirme
                11.6.3.1  Cache
                11.6.3.2  slab
    12  Kernel'in bellek yönetimi 2 - Tanenbaum: Modern Operating Systems 2014 ch 3
        12.1  Model 1: Memory abstraction yok
        12.2  Model 2: Base ve limit register'ları ile memory abstraction
        12.3  Swapping
        12.4  Boş belleğin yönetimi
            12.4.1  bitmap ile
            12.4.2  linked list ile
        12.5  Sanal bellek (virtual memory)
            12.5.1  Paging
                12.5.1.1  page
                12.5.1.2  page frame
                12.5.1.3  page table
                12.5.1.4  page table entry
                12.5.1.5  TLB (translation lookaside buffer) 
                    12.5.1.5.1  Çalışması
                12.5.1.6  Soft miss
                12.5.1.7  hard miss
                12.5.1.8  page table walk
                12.5.1.9  minor page fault
                12.5.1.10  major page fault
                12.5.1.11  segmentation fault
                12.5.1.12  multilevel page tables
                12.5.1.13  inverted page table
                12.5.1.14  Page replacement algoritmaları
                12.5.1.15  İdeal page size
                12.5.1.16  Instruction ve data space'leri ayrı tutmak
                12.5.1.17  Shared pages ve COW (copy on write)
                12.5.1.18  Shared libraries
                12.5.1.19  Mapped files
            12.5.2  Adım adım paging
            12.5.3  Adım adım page fault handling
            12.5.4  Diske page yedekleme
            12.5.5  Segmentation
                12.5.5.1  x86-64: Segmentation artık yok
                12.5.5.2  x86: Segmentleri page'lemek
                    12.5.5.2.1  LDT (local descriptor table)
                    12.5.5.2.2  GDT (global descriptor table)
                    12.5.5.2.3  segment:offset -> fiziksel adres dönüşümü
    13  Random notes to put somewhere in the note
        13.1  KASLR -> KAISER -> PTI
        13.2  Spinlock
    14  Notes from pwn.college kernel module
        14.1  Rings
        14.2  Different types of OS models
        14.3  How kernel handles syscalls
        14.4  Kernel memory vs userspace memory
        14.5  Possible kernel attack vectors
        14.6  Kernel modules
            14.6.1  Ways to interact w/ kernel modules
            14.6.2  Syscall hooking
            14.6.3  Interrupt hooking
            14.6.4  Interation w/ modules via files
                14.6.4.1  read() and write()
                14.6.4.2  ioctl()
                14.6.4.3  Kernel Race Conditions
                14.6.4.4  On credentials
    15  Kernelde Güvenlik
        15.1  SELinux
            15.1.1  Bypassing SELinux
        15.2  SecComp
    16  Misc
        16.1  UML (user mode linux)
        16.2  Linux insides kalinan yer:
        16.3  rawsploit: libc çok büyük gelince
        16.4  AMD64 Kernel calling conventions
    17  Fuzzing
    18  Android SDK emulator kullanımı
        18.1  Start emulator
        18.2  Start gdb
        18.3  Set cpu cores to 1
    19  Rastgele Exploitation Notları
        19.1  Data-only attacks
        19.2  addr_limit on arm64
        19.3  DiShen's UAF exploitation gadget: "struct iovec"
            19.3.1  How to pwn with this?
        19.4  Always winning the races w/ userfaultfd
        19.5  seq_operations'un ilk pointer'ını ezmenin yeterli oluşu
        19.6  Stack pivot gadget'indeki adresin son 3 byte'ı 0'dan farklı olmalı
        19.7  mov rdi, rax --> mov edi, eax 'a dönüşüyor ve patlatıyor
        19.8  swapgs_restore_regs_and_return_to_usermode yerine kullanılabilecekler

--[1] Önsöz

    Bu yazı linux'da userspace binary exploitation konusuna aşina olup da,
    kernel exploitation'a giriş yapan birisi tarafından tutulan notlardan
    oluşmaktadır. Hedef okuyucu kitlesi de benzer nitelikte bilgi sahibi
    kişilerdir. Bir "not", yani kişisel ihtiyaçlara yönelik yazılmış bir yazı;
    aynı zamanda da yayınlanmış bir yazı, yani biraz konu bağlamı derli toplu
    tutulmaya çalışıldı. Konuya başlayanlar için birincil kaynak olarak okunsun
    diye değil de, konu başlıklarından haberdar etsin diye yazıldı.
    İngilizce/Türkçe karışık bir not oldu. Kernel'e yeni girmiş biri olarak
    yazarın bilmediği çok şey var, yazının büyük çoğunluğu kopyalanmış içerik;
    yazarın tahminsel olarak sunduğu fikirlerin kesin doğru olmadığı ise
    uyarılar ile belirtilmeye gayret edildi.

    Yanlışım varsa pullrequest lütfen.


--[2] Amaç

    Neden linux kernelini hacklemek isteyelim?

    - Telefonumuzun ya da oyun konsolumuzun üzerinde tam kontrolü elde
      edebiliriz.
    - Yazılımsal çok fazla güvenlik önlemi varsa (sandbox vs.) onları teker
      teker aşmak yerine tek seferde sistemi ele geçirebiliriz.
    - Sisteme rootkit ya da bootkit yerleştirmek istiyor olabiliriz.
    - Milyarlarca linux çalıştıran cihazın olduğu bir gezegeni ele
      geçirebiliriz.
    - Root parolamızı unutmuşsak kolayca (!) sıfırlayabiliriz.
    - Öylesine.

    Tabii ki kernel exploit, userspace exploitation'dan sonraki zincir. Yani
    kerneli kırmak için en başta sistemde kod çalıştırabilir konumda
    olmalısınız. Mesela bir browser exploit'iniz var, bunu kernel exploitle
    zincirliyorsunuz vs.


--[3] Kaynakları edinin
    
    Kernel'in en güncel dökümantasyonu her zaman kodun kendisi. Çok sık
    gelişen bir proje olarak linux kernel'inin sabit bir dökümantasyonu
    bulunmuyor. Ayrıca userspace'deki gibi manpages da yok; bir fonksiyonun
    ya da makronun ne iş yaptığını öğrenmek için genellikle kodunu okumanız
    gerekiyor.

    Kodu iyi okuyabileceğiniz bir ortam elzem. Aradığımız fonksiyonu,
    sembolü kolayca bulabilir olmalıyız. Bir kaç seçenek var:

    1) Online: https://elixir.bootlin.com/linux/v5.8-rc4/source
    2) Kodu yerele çekip 'grep' veya 'git grep'le arama yapmak
    3) Kodu yerele çekip vim'de gtags (GNU Global) eklentisi kullanmak
    4) Kodu yerele çekip vim'de ctags eklentisi kullanmak
    5) Kodu yerele çekip bir IDE'de (eclipse vs.) açmak
    6) DDG, google vs..

    Ben gtags'i seçtim, yerelde kaynakların bulunması iyidir. 'gtags.vim'
    eklentisinde önerilen kısayolları da aktifleştirince kolayca kod
    üzerinde zıplayabilir oluyoruz.


--[4] Lab ortamı kurulumu

    Başlangıç için lab kurmak yerine halka açık ctf ortamlarındaki kernel
    sorularına odaklanmak daha mantıklı. Kerneli derlemek birkaç saat
    sürebiliyor falan... Yine de Ubuntu VM içinde QEMU ile gitmek istersek
    eksik notlar şu şekilde:

    1) Install ubuntu on VM (I've installed ubuntu server 20.04 on vbox)
       - Hey, why not docker? anyways..
    2) Download a kernel tarball from kernel.org
    3) sudo apt install gcc build-essential libncurses5-dev kernel-package
       bison flex libssl-dev libelf-dev dkms libudev-dev libpci-dev 
       libiberty-dev autoconf
    4) make menuconfig    # all needed debug options was set surprisingly,
                          # kgdb, frame pointers, debug info etc. no need to
                          # change anything; just play around
    5) make

    Then install busybux

    1) Download a busybox tarball from https://busybox.net/downloads/
    2) make menuconfig
    3) make

    ----8<---- 

    Devamı için: https://www.cnblogs.com/hac425/p/9416886.html


--[5] CTF'ler

    pwnable.kr tasks (syscall, rootkit, softmmu, towelroot, kcrc, exynos)


--[6] Kernel ne işe yarıyor?

    "Ooo kernel, en derin, ring-0, matrix" falan filan diyoruz ama samimi
    olarak ne yaptığını anlamamız lazım.

    Basitçe kernel:
    1) Donanımları işletir
    2) Kullanıcı uygulamalarının çalışacağı bir ortam sağlar

    Bunları şunlarla yapar:
    - Donanımları yazılımsal olarak sürer (device drivers)
    - Birden çok olan işlemlerin zaman planlamasını yapar (task scheduling)
    - Diski yönetir ve dosya sistemi sunar
    - Belleği yönetir, virtual memory falan sağlar
    - Kullanıcılara syscall'lar sağlar
    - vs...

    
----[6.1] Kernel map

        \Function|  human   |        |            |     |         |       
    Layer\       |interface | system | processing | mem | storage | network
    -------------+---------------------------------------------------------
    user space   |
    interfaces   |
    -------------+
    virtual      |
    -------------+
    bridges      |
    -------------+          (https://makelinux.github.io/kernel/map/)
    logical      |               (Not: kernel 2.6.36; eski!)
    -------------+
    device control
    -------------+
    hw interfaces|
    -------------+
    electronics  |
    -------------+


----[6.2] Kernel 5.8'in codebase'ini biraz incelersek:

   ~/srcs/linux 0 $ ls -laF
    arch/      --> architecture specific codes
    block/     --> ?
    crypto/    --> crypto implementations
    drivers/   --> device drivers (biggest part of the kernel)
    fs/        --> filesystem
    include/   --> header files
    init/      --> ??bootloader stuff??
    ipc/       --> inter process communications
    kernel/    --> ?
    lib/       --> ?
    mm/        --> memory management
    net/       --> networking
    samples/   --> ?
    security/  --> security subsystems
    sound/     --> sound subsystems
    tools/     --> ?
    usr/       --> ?
    virt/      --> ??virtualization subsystems??


--[7] Ring goygoyu

    CPU'lar katmanlı bir güvenlik mimarisi sağlar. 4 katman için yapı:

    Ring 3  --> Kullanıcı uygulamaları
    Ring 2  --> (Günümüzde pek kullanılmıyor)
    Ring 1  --> (Günümüzde pek kullanılmıyor)
    Ring 0  --> Kernel

    Root olmak ring 0'da olmak anlamına gelmiyor; hala userspacedeyiz!

    Syscall'lar kernelin kullanıcılara sunduğu "API"si olduğu için, bir
    syscall kullandığımız zaman (mesela "chown") işlemci ring 0'a
    geçiyor, syscall'ı çalıştırıyor ve tekrar ring 3'e zıplıyor.



--[8] Kernel Exploitation Temelleri

----[8.1] Basit exploitation stratejisi - Büyük resim:

    1) Kernel kodunda bir zafiyet bul
    2) Bu zafiyeti sömürerek kod çalıştır
    3) Kendi işleminin yetkilerini root'unkine yükselt 
    4) Kernelden userland'e geri dön
    5) Root yetkileriyle hoş vakit geçir*

    *Kernel'de neden kalmıyoruz: Çünkü kernel uzayında networking,
     dosya okuma/yazma, process oluşturma vs. userspace'e göre çok
     zahmetli. Userspace'e bu yüzden dönmeyi tercih ediyoruz.

----[8.2] Kernel'de nasıl zafiyetler var?

    Userspace'dekilerin aynıları! Yani:
     - Buffer overflows
     - Signedness issues
     - Partial overwrites
     - Use-after-free's
     - TOCTOU
     - Race conditions
     - ...

----[8.3] Bu zafiyetleri nasıl sömürülür?

    Userspace'dekiler sömürdüğümüz gibi! Yani:
     - Shellcoding
     - ROP
     - Pointer overwrites
     - Type confusion
     - Memory leaking (KASLR!)
     - ...

----[8.4] Bazı kernel güvenlik önlemleri ve aşma yöntemleri

    - DEP: ROP
    - KASLR: Memory leak
    - Canaries: Memory leak, ya da heap'e yöneliş
    - SMEP: Supervisor Mode Execution Protection. Userspace'deki shellkodun
            kernelden çalıştırılmasını engelliyor, SMEP yokken kernel
            RIP'ini doğrudan userspace'deki bir shellcode'a zıplatmak
            mümkündü. SMEP olunca ROP yapmak zorundayız. Ama rop chainimiz
            userspace'de tutulabiliyor; bunu engellemiyor.
    - SMAP: Supervisor Mode Access Protection, kernel'dan userspace'e
            erişimi engelliyor. Yani artık ROP chainimizi de userspace'de
            tutamıyoruz; mecbur bir kernel bufferına yazmak zorundayız
            chainimizi. Belli register'ların (x86'da CR3) belli
            bitlerini ROP'la değiştirerek kapatılabiliyorlar bunlar.
    - LSM: Linux Security Modules. Apparmor, selinux ve security/
           dizinindeki diğer modüller. Erişim konusunda fazladan katman
           sağlıyorlar. Sandbox'ing falan. Detay bilmiyorum.
    - PIE ve RELRO kernel için söz konusu değil

    Not: Bunlar işlemcinin sunduğu özelliklerle doğrudan alakalı; mesela
         SMEP/SMAP x86'nın özellikleri

    - Diğer: mmap_min_addr değişkeni (null ptr deref için çözüm).
             Eskiden bir program mmap(0,...) şeklinde 0 adresine kodunu
             yazsa ve kernelde bir null ptr dereference tetiklese kernel
             0 adresindeki shellcode'u çalıştırmaya başlarmış...
             mmap_min_addr limiti, mmap ile düşük adreslerin alınmasını
             engelliyor, NULL ptr deref hatalarının sömürülmesini
             oldukça zorlaştırıyor.


----[8.5] Debugging

    - Çoğu zaman crash dump'larına dayanacağız, bunlarda değerli
      bilgiler olabiliyor (stack, register dumpları vs)
    - Systemtap; scriptlerle kernel fonksiyonlarını hooklamayı
      sağlıyor,debug sembolleri gerekiyor
    - Netconsole; dmesg'in network tabanlı olanı, crash dumpları dmesg'e
      basılmadan kernel çökebiliyor. Netconsole daha garanti
    - Qemu ve vmware gdb arayüzü sağlıyormuş
    - Virtualbox'u bilmiyorum
    - Kernel derlenirken menuconfig üzerinden debug symbolleri ve pek
      çok diğer debug seçeneği açılabiliyor
    - Debug sembolleri sonradan paket olarak da indirilebiliyor
    - NOT: Debug sembollü bir kernel'de geliştirilen exploit yüksek
      ihtimalle standart kernelde çalışmaz (adres kaymaları vs.)


----[8.6] Nerelerde zafiyetler var?

------[8.6.1] LKM (Loadable Kernel Module)

    En sık LKM'lerde (Loadable Kernel Module) bulunuyormuş.

    LKM'ler, kernel space'de çalışan exe'ler gibi. Modül olduğu için kernel
    çalışırken eklenebiliyor, çıkartılabiliyor vs. Tek başına derlendikleri içın
    kernel'le beraber saatlerce derlenmesini beklemenize de gerek yok, bu yüzden
    driver'ların belki de çoğu LKM halinde bulunuyor.


--------[8.6.1.1] LKM'lerin kullanım alanları:

    - Device drivers
    - Filesystem drivers
    - Networking drivers
    - Executable interpreters
    - Kernel extensions
    - Rootkits (lol)


--------[8.6.1.2] LKM dosya yapısı

    Linux için bildiğimiz ELF! Yani reverse yaparken userspace için
    kullandığımız tool'ları kullanabiliyoruz.


--------[8.6.1.3] LKM'lerle çalışmak için komutlar

    $ modprobe   # 'zekice' modülü kernele yükle/kaldır
    $ insmod     # biraz uğraştırarak modülü yükle
    $ rmmod      # modülü kaldır
    $ lsmod      # yüklü modülleri listele


--[9] Proc cheatsheet

    $ grep "smep" /proc/cpuinfo
    $ grep "smap" /proc/cpuinfo
    $ cat /proc/iomem
    $ cat /proc/slabinfo
    $ cat /proc/<pid/maps> # vmmap per pid
    $ cat /proc/self/maps  # caller proceses's vmmap
    $ cat /proc/cmdline # check if kaslr, kaiser or pti is enabled


--[10] Önemli kernel yapıları, fonksiyonlar vs. kernel v5.8 için sunulmuştur 
  
    (K: blog.lexfo.fr). UYARİ: Kod parçalarında kırpmalar yapılmıştır.


----[10.1] task_struct: "işlem"in tanımı

    Kendi exploit process'imizin yetkilerini root yapma isteyeceğimizden bir
    process nasıl tanımlanıyor bilmeliyiz.

        --------------------------------------------------------------------
        // include/linux/sched.h

        struct task_struct {
            void                                    *stack;
            refcount_t                              usage;
            int                                     prio;

            struct mm_struct                        *mm;
            pid_t                                   pid;
            unsigned long                           stack_canary;

            /* Real parent process: */
            struct task_struct __rcu                *real_parent;

            /* Recipient of SIGCHLD, wait4() reports: */
            struct task_struct __rcu                *parent;

            /*
             * 'ptraced' is the list of tasks this task is using ptrace() on.
             *
             * This includes both natural children and PTRACE_ATTACH targets.
             * 'ptrace_entry' is this task's link on the p->parent->ptraced list.
             */
            struct list_head                        ptraced;
            struct list_head                        ptrace_entry;

            /* Objective and real subjective task credentials (COW): */
            const struct cred __rcu                 *real_cred;

            /* Effective (overridable) subjective task credentials (COW): */
            const struct cred __rcu                 *cred;

            /* Open file information: */
            struct files_struct                     *files;

            struct seccomp                          seccomp;

            struct vm_struct                        *stack_vm_area;

            /* A live task holds one reference: */
            refcount_t                              stack_refcount;

            /* Used by LSM modules for access restriction: */
            void                                    *security;

            /* CPU-specific state of this task: */
            struct thread_struct                    thread;

            // ...
        };
        --------------------------------------------------------------------

    En çok "cred" alanı ilgimizi çekiyor zira işlemin yetkileri burada tanımlı.


----[10.2] cred struct: işlemin yetkilerinin tanımı

        --------------------------------------------------------------------
        // include/linux/cred.h

        struct cred {
            kuid_t          uid;            /* real UID of the task */
            kgid_t          gid;            /* real GID of the task */
            kuid_t          suid;           /* saved UID of the task */
            kgid_t          sgid;           /* saved GID of the task */
            kuid_t          euid;           /* effective UID of the task */
            kgid_t          egid;           /* effective GID of the task */
            kuid_t          fsuid;          /* UID for VFS ops */
            kgid_t          fsgid;          /* GID for VFS ops */
            unsigned        securebits;     /* SUID-less security management */
            kernel_cap_t    cap_inheritable;/* caps our children can inherit */
            kernel_cap_t    cap_permitted;  /* caps we're permitted */
            kernel_cap_t    cap_effective;  /* caps we can actually use */
            kernel_cap_t    cap_bset;       /* capability bounding set */
            kernel_cap_t    cap_ambient;    /* Ambient capability set */


        #ifdef CONFIG_SECURITY
            void            *security;      /* subjective LSM security */
        #endif
            struct user_struct *user;       /* real user ID subscription */
            struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
            struct group_info *group_info;  /* supplementary groups for euid/fsgid */

            // ...
        }
        --------------------------------------------------------------------

    Kernel exploitlerin aşağı yukarı ortak amacı istenilen process'in cred
    struct'unu bulup bu "kgid_t" tipindeki değişkenleri 0 (root) yapmak oluyor.

    Bunun dışında bu cred struct'ında 'capability'ler, 'namespace'ler ve LSM'ye
    (Selinux, apparmor vs) ait tanımlamalar görüyoruz.


------[10.2.1] "current" makrosu: o anki koşan işleme pointer

    current makrosu farklı mimariler için farklı şekilde çalışan, ama asıl amacı
    çekirdekte o anki çalışan işleme işaret eden pointer döndürmek olan sık
    rastlanan makro.

    x86 için:

        --------------------------------------------------------------------
        // arch/x86/include/asm/current.h

        DECLARE_PER_CPU(struct task_struct *, current_task);

        static __always_inline struct task_struct *get_current(void)
        {
            return this_cpu_read_stable(current_task);
        }

        #define current get_current()
        --------------------------------------------------------------------

    this_cpu_read_stable inline assembly ile yazılmış, current_task değişkenine
    o anki çalışan işlemin task_struct'unun pointer'ını döndüren bir makro.


----[10.3] file, fdtable, files_struct: dosyalar

    "Linux'ta her şey dosyadır" sözünün manasını tam kavrayalım.  Temel olarak 7
    dosya türü var:
        1) Normal dosya (.txt falan)
        2) Dizin
        3) Link ("kısayol")
        4) Character device (seri port, modem, ses, video, klavye..)
        5) Block device (hdd vs.)
        6) FIFO
        7) Socket

    File descriptor'lar özünde bir integer'dan ibaret; ve sadece ait olduğu
    process için anlam taşıyor. Her fd'nin bağlantılı olduğu bir "struct file"
    var.

        --------------------------------------------------------------------
        // include/linux/fs.h

        struct file {
            struct path                     f_path;
            struct inode                    *f_inode; /* cached value */
            const struct file_operations    *f_op; // Virtual function
                                                   // table pointer

            atomic_long_t                   f_count; // obj reference count
            loff_t                          f_pos;   // cursor position
            struct fown_struct              f_owner;
            const struct cred               *f_cred;

        #ifdef CONFIG_SECURITY
            void                            *f_security;
        #endif
            /* needed for tty driver, and maybe others */
            void                            *private_data;
            
            // ...
        }
        --------------------------------------------------------------------

    File descriptor bir integer demiştik (0=stdin, 1=stdout, 2=stderr,
    3=dosya.txt, 4=...). Process için bu integerların karşılıklarındaki "file"
    yapılarını eşleştiren tablo "fdtable".

        --------------------------------------------------------------------
        // include/linux/fdtable.h
        
        struct fdtable {
            unsigned int max_fds;
            struct file __rcu **fd;      /* current fd array */

            // ...
        };
        --------------------------------------------------------------------

    Process'in kendisine ait fdtable "files_struct" türündeki struct'ta
    tutuluyor (bkz: task_struct). Neden doğrudan "fdtable" olarak tutmuyor
    derseniz; çünkü files_struct'ta process için gerekli fazladan bilgiler de
    var ve derli toplu durmaları için böyle bir wrapper yapmışlar sanıyorum.

        --------------------------------------------------------------------
        // include/linux/fdtable.h

        struct files_struct {
            atomic_t count;                         // obj reference ctr
            struct fdtable __rcu *fdt;              // ptr to fdtable
        
            // ...
        }
        --------------------------------------------------------------------


----[10.4] Virtual function table (vft) yaklaşımı

    C ile yazılmış olsa da linux kerneli object-oriented bir kernel.  VFT'ler,
    kernele OOP'lik katan yaklaşımlardan. Kısaca, fonksiyon pointer'ları tutan
    struct'lar.

    En meşhur VFT'lerden biri "file_operations" struct'ı:

        --------------------------------------------------------------------
        // include/linux/fs.h

        struct file_operations {
            loff_t (*llseek) (struct file *, loff_t, int);
            ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
            ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
            int (*mmap) (struct file *, struct vm_area_struct *);
            int (*open) (struct inode *, struct file *);
            int (*flush) (struct file *, fl_owner_t id);
            int (*release) (struct inode *, struct file *);
            
            // ...
        }
        --------------------------------------------------------------------

    Her şeyin dosya olduğu ama dosyaların farklı farklı biçimlerde olduğu
    (soket, dosya, dizin vb...) linux'da vft yaklaşımıyla mesela dosya okuma
    işlemleri "generic"lik kazanarak şu hale geliyor:

        --------------------------------------------------------------------
            // soket için de, dizin için de, dosya için de...
            if (file->f_op->read)
                ret = file->f_op->read(file, buf, count, pos);
        --------------------------------------------------------------------
        
    Çünkü her dosyanın "f_op"sundaki fonksiyon pointer'ları kendi türünün özel
    fonksiyonlarına işaret ediyor.

    Kernel exploitlerinde fonksiyon pointer'ları ile oyunlar yapmak çok sık
    başvurulan bir yöntem olduğu için (mesela UAF) bu yapıyı da bilelim.


----[10.5] socket, sock, skb: ağ

    socket(2) syscall'ı ile yeni bir soket oluşturunca, kernel bizim için bir
    "struct file" oluşturur ve "f_op" alanını "socket_file_ops" olarak ayarlar.
    Özünde dosya oldukları için de klasik open(2), write(2) gibi syscall'larla
    çalışırlar.

        --------------------------------------------------------------------
        // net/socket.h

        struct socket {
                socket_state                state;

                short                       type;

                unsigned long               flags;

                struct file                 *file;
                struct sock                  *sk;
                const struct proto_ops      *ops;

                struct socket_wq            wq;
        };

        static const struct file_operations socket_file_ops = {
            .llseek =       no_llseek,
            .read_iter =    sock_read_iter,
            .write_iter =   sock_write_iter,

            // ...
        }

        struct proto_ops {
                int                family;
                int                (*release)   (struct socket *sock);
                int                (*bind)             (struct socket *sock,
                                              struct sockaddr *myaddr,
                                              int sockaddr_len);
                int                (*connect)   (struct socket *sock,
                                              struct sockaddr *vaddr,
                                              int sockaddr_len, int flags);
                int                (*sendmsg)   (struct socket *sock, struct msghdr *m,
                                              size_t total_len);
                int                (*recvmsg)   (struct socket *sock, struct msghdr *m,
                                              size_t total_len, int flags);

            // ...
        }
        --------------------------------------------------------------------

    Burada ne görüyoruz: socket struct'ı, file stuct'ı için bir "wrapper" olarak
    yazılmış. socket->file->f_op şeklinde open, close işlemlerine erişildiği
    gibi ayrıca özünde BSD socket API'sinin gerçeklemesi olduğundan, proto_ops
    ile socket'in bind, release gibi BSD çıkışlı fonksiyonları da gerçeklenmiş.

    struct socket, yine de bir "dosya" türü olarak tasarlandığından "high-level"
    bir yapı olarak sayılabilir. Fakat sıradan dosyalardan farklı olarak
    soketler network kartına gidip okuma/yazma işlemleri yaparlar; bu gibi
    low-level işlemler için struct socket'in içinde bir de "struct sock" diye
    bir veri yapısına pointer var. sock'da daha detaylı işler dönüyor:

        --------------------------------------------------------------------
        // include/net/sock.h

        struct sock {
                struct sk_buff_head        sk_error_queue;
                struct sk_buff_head        sk_receive_queue;
                int                        sk_rcvbuf;
                int                        sk_sndbuf;
                struct sk_buff_head        sk_write_queue;

                struct socket              *sk_socket;
        #ifdef CONFIG_SECURITY
                void                       *sk_security;
        #endif

                // ...
        };
        --------------------------------------------------------------------

    Mesela ağ üzerinden bir paket gelince, ağ kartının sürücüsü bunu
    sk_receive_queue'ya alır, bir program recvmsg(2) syscall'ını çağırana kadar
    o queue'da kalır o paket.

    Bu paketler ise, sk_buff'lardır (kısaca skb):

        --------------------------------------------------------------------
        // include/linux/skbuff.h

        struct sk_buff {
                union {
                        struct {
                                /* These two members must be first. */
                                struct sk_buff                *next;
                                struct sk_buff                *prev;

                                union {
                                        struct net_device     *dev;
                                        // ...
                                };
                        };
                };

                union {
                        struct sock                *sk;
                        int                        ip_defrag_offset;
                };

                unsigned int                len,
                                            data_len;
                __u16                       mac_len,
                                            hdr_len;

                __be16                      protocol;
                __u16                       transport_header;
                __u16                       network_header;
                __u16                       mac_header;

                unsigned char               *head,
                                            *data;

                refcount_t                  users;

                // ...
        };
        --------------------------------------------------------------------

    struct sock'un içindeki queue'larda tutulan sk_buff'un içinde temel network
    terimlerini görmeye başladık. Ayrıca *data pointerını görüyoruz. Sonunda
    veriye ulaştık yani!

    Yukarıdaki veri yapılarının her birinde bir üst ve bir alt katmana işaret
    eden pointerlar mevcut. Bu katmanlar OSI katmanları DEĞİL!  Kernel'in
    katmanları. Özet diyagramı:

                  +-----------------------------------+
                  |   struct file {                   | 
              high|           void *private_data;     |
             level|   }                               |
                  |               |   ^               |
                  | - - - - - - - | - | - - - - - - - |
                  |               V   |               |
                  |   struct socket {                 |
                  |           struct file *file;      |
                  |           struct sock *sk;        |
                  |   }                               |
                  |               |   ^               |
                  | - - - - - - - | - | - - - - - - - |
                  |               V   |               |
                  |                                   |              
                  |   struct sock {                   |
                  |           struct socket *sk_sock; |
                  |           struct sk_buff_head sk_XXX_queue;
                  |   }                               |
                  |               |   ^               |
                  | - - - - - - - | - | - - - - - - - |
                  |               V   |               |
                  |                                   |
              low |   struct sk_buff {                |
             lovel|           struct sock *sk;        |
                  |   }                               |
                  +-----------------------------------+
                       Şekil: Kernel network stack   

        Dikkat: "struct socket"ler genelde "sock" olarak,
                "struct sock"lar da genelde "sk" olarak
                isimlendirilirler.


----[10.6] netlink_sock: IPC için özel soket

    socket'ler sadece network işleri için kullanılmıyorlar.  Özelleştirilmiş bir
    socket olan netlink_sock, inter process communication'da kullanılıyor.
    Ayrıca kernel ve userspace arası haberleşme için de kullanılıyor.
        
        --------------------------------------------------------------------
        // net/netlink/netlink_sock.h

        struct netlink_sock {
                /* struct sock has to be the first member of netlink_sock */
                struct sock                sk;
                u32                        portid;
                u32                        dst_portid;
                u32                        dst_group;

                // ...
        };
        --------------------------------------------------------------------

    Yorum satırına dikkat! İlk elemanın "struct sock" olması ne işe yarar
    dersiniz? C dilinde type polymorphism bu şekilde yapılıyormuş.
    &netlink_sock == &netlink_sock.sk oluyor ve bunlardan birini "free" etmek,
    bir diğerinin free olması anlamına geliyor.
    
    Tabii netlink için socket'in özelleştirilmiş proto_ops'a gereği var:

        --------------------------------------------------------------------
        // net/netlink/af_netlink.c

        static const struct proto_ops netlink_ops = {
                .family =   PF_NETLINK,
                .owner =    THIS_MODULE,
                .release =  netlink_release,
                .bind =     netlink_bind,
                .connect =  netlink_connect,

                // ...
        }
        --------------------------------------------------------------------


----[10.7] Hepsi bir arada: current, task_struct, files_struct, fdtable,
                         file. socket, sock, sk_buff, socket_file_ops, 
                         netlink_sock, netlink_ops


            current
               |
               V
          task_struct
               |
             *files
               |
               V
         files_struct
               |
              *fdt
               |
               V
            fdtable
               |
              **fd                    sk_buff
               |                        ^|
               V                        |v    
      +----------------------+     netlink_sock
      | 0xffffff12345 // [0] |        (sock)
      +----------------------+          ^|
      | 0xffffff12567 // [1] |          |v
      +----------------------+        socket --*proto_ops--> netlink_ops
      |                      |          ^|
      +----------------------+          |v
      | 0xffffff12987 // [9] |------> file --*f_op--> socket_file_ops
      .                      .
      .                      .

                    Şekil: Hepsi bir arada (oklar pointer)
                           Pointer isimlerinin hepsi yazilmadı


----[10.8] Reference counter kavramı

    C ile yazıldığı için kernelde use-after-free gibi hatalara yer vermemek ve
    bellek sızdırmamak geliştiricilerin sorumluluğunda.  Bunun için refcounting
    yaklaşımı geliştirilmiş. Kısaca, bellekteki bir objeye eriştiğiniz zaman
    (mesela socket olsun), refcount'u 1 arttırılıyor. Kullanım bitince de 1
    azaltılıyor. Refcount 0 olduğu an obje otomatik siliniyor (free).

    Ha tabii, c++'daki gibi smart pointer kavramı olmadığı için tüm bu refcount
    arttırma ve düşürme işlemleri, o objeye erişen kodu geliştiren kişi
    tarafından elle yapılmalı. Bir socket objesi kullanacaksanız, o socket'in
    refcount'unu (helper fonksiyonlar ile) arrtırmalısınız. Mesela:

        --------------------------------------------------------------------
        static __always_inline void __sock_put(struct sock *sk)
        {
                refcount_dec(&sk->sk_refcnt);
        }
        --------------------------------------------------------------------

    Bu arttırma ve azaltma işlemlerini "generic"leştirmek için girişimlerde
    bulunulmuş olsa da (kref, kobject gibi) genelde her yapı kendi refcount
    sistemini kurmuş durumda. Referans almak (taking a reference == ref++)
    _get()'imsi helper'larla, referans bırakmak ise (dropping a reference ==
    ref--) _put()'umsu helper fonksiyonlarla sağlanıyor.

    Yukarıdaki veri yapılarında da görülebileceği gibi, refcount, count, usage
    gibi farklı farklı isimlendirmeler var. Helper fonksiyonlar için de farklı
    isimler var:

        struct sock         : sock_hold(), sock_put()
        struct file         : fget(), fput()
        struct files_struct : get_files_struct(), put_files_struct()

    gibi.

    Ama mesela skbuff'ların skb_put() fonksiyonunun refcountingle alakası yok.
    Kernel'da isimlendirmelere bakıp da içerik hakkında tahminde bulunma; git ne
    iş yapıyor bak!

    Hülasa; elle yapılan bir refcount arttırma azaltma söz konusu olunca,
    karışık "path"lerde programcı hatalarından kaynaklı UAF'ler, double
    free'ler, integer overflow'lar (ve buna bağlı UAF'ler) kernelin her yerinde
    karşımıza çıkabilir.


----[10.9] Understanding page fault trace

    Rootkitimizi insmod yaptık ve oops!
       
        --------------------------------------------------------------------
        / # insmod wootkit
        [   39.847344] BUG: unable to handle kernel paging request at c15fa0b8
        [   39.848063] IP: [<c47fa006>] initmodule+0x6/0x1000 [wootkit]
        [   39.848063] *pdpt = 00000000019aa001 *pde = 0000000002b07063 *pte = 00000000015fa161
        [   39.848063] Oops: 0003 [#1] SMP
        [   39.848063] Modules linked in: wootkit(POF+)
        [   39.848063] Pid: 77, comm: insmod Tainted: PF          O 3.7.1 #1 QEMU Standard PC (i440FX + PIIX, 1996)
        [   39.848063] EIP: 0060:[<c47fa006>] EFLAGS: 00000246 CPU: 0
        [   39.848063] EIP is at initmodule+0x6/0x1000 [wootkit]
        [   39.848063] EAX: c15fa0b8 EBX: 00001449 ECX: 00000002 EDX: 00000001
        [   39.848063] ESI: c47fa000 EDI: 00000000 EBP: c26dbee4 ESP: c26dbeb4
        [   39.848063]  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
        [   39.848063] CR0: 8005003b CR2: c15fa0b8 CR3: 02d81000 CR4: 000006b0
        [   39.848063] DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000
        [   39.848063] DR6: ffff0ff0 DR7: 00000400
        [   39.848063] Process insmod (pid: 77, ti=c26da000 task=c2ede580 task.ti=c26da000)
        [   39.848063] Stack:
        [   39.848063]  c26dbee4 c1003152 00000000 00000000 00000000 00000000 c47fb000 c26dbee4
        [   39.848063]  c10a6532 00001449 c47f7000 c2eeab40 c26dbfac c10a7db3 00001449 c187d8a8
        [   39.848063]  00000000 c17ea42c c47f700c 00150000 00000014 00001000 00001000 c3b5f000
        [   39.848063] Call Trace:
        [   39.848063]  [<c1003152>] ? do_one_initcall+0x112/0x160
        [   39.848063]  [<c10a6532>] ? set_section_ro_nx+0x62/0x80
        [   39.848063]  [<c10a7db3>] sys_init_module+0xf3/0x1d00
        [   39.848063]  [<c15f5ccd>] sysenter_do_call+0x12/0x28
        [   39.848063] Code: <c7> 00 d8 a4 ff 32 80 c4 20 a0 5f c1 90 2c 02 10 55 90 bc a4 5f c1
        [   39.848063] EIP: [<c47fa006>] initmodule+0x6/0x1000 [wootkit] SS:ESP 0068:c26dbeb4
        [   39.848063] CR2: 00000000c15fa0b8
        [   39.848063] ---[ end trace af0d9cc236996cb9 ]---
        Killed
        --------------------------------------------------------------------


    "Oops" kodlarımız:

        --------------------------------------------------------------------
        // arch/x86/include/asm/traps.h

        /*
         * Page fault error code bits:
         *
         *   bit 0 ==    0: no page found       1: protection fault
         *   bit 1 ==    0: read access         1: write access
         *   bit 2 ==    0: kernel-mode access  1: user-mode access
         *   bit 3 ==                           1: use of reserved bit detected
         *   bit 4 ==                           1: fault was an instruction fetch
         *   bit 5 ==                           1: protection keys block access
         */
        enum x86_pf_error_code {
                X86_PF_PROT     =               1 << 0,
                X86_PF_WRITE    =               1 << 1,
                X86_PF_USER     =               1 << 2,
                X86_PF_RSVD     =               1 << 3,
                X86_PF_INSTR    =               1 << 4,
                X86_PF_PK       =               1 << 5,
        };
        --------------------------------------------------------------------

    Örnekteki 0003 == X86_PF_PROT | X86_PF_WRITE;


--[11] Kernel'in bellek yönetimi

    Kernel'in en kritik görevlerinden biri belleği hızlı, güvenli, stabil ve
    "fragmentation" en az olacak şekilde yönetmesidir.

    Burada mmap başlığı dahil "LDD3 - Chapter 15, Memory Mapping and DMA'den
    alıntılar var. (http://static.lwn.net/images/pdf/LDD3/ch15.pdf)

----[11.1] List of address types used in Linux

------[11.1.1] User virtual addresses

    These are the regular addresses seen by user-space programs.  User addresses
    are either 32 or 64 bits in length, depending on the underlying hardware
    architecture, and each process has its own virtual address space.

------[11.1.2] Physical addresses

    The addresses used between the processor and the system's memory. Physical
    addresses are 32- or 64-bit quantities; even 32-bit systems can use larger
    physical addresses in some situations.

------[11.1.3] Bus addresses

    The addresses used between peripheral buses and memory. Often, they are the
    same as the physical addresses used by the processor, but that is not
    necessarily the case. Some architectures can provide an I/O memory
    management unit (IOMMU) that remaps addresses between a bus and main memory.
    An IOMMU can make life easier in a number of ways (making a buffer scattered
    in memory appear contiguous to the device for example), but programming the
    IOMMU is an extra step that must be performed when setting up DMA
    operations. Bus addresses are highly architecture dependent, of course.

------[11.1.4] Kernel logical addresses

    These make up the normal address space of the kernel. These addresses map
    some portion (perhaps all) of main memory and are often treated as if they
    were physical addresses. On most architectures, logical addresses and their
    associated physical addresses differ only by a constant offset. Logical
    addresses use the hardware's native pointer size and, therefore, may be
    unable to address all of physical memory on heavily equipped 32-bit systems.
    Logical addresses are usually stored in variables of type unsigned long or
    void *. Memory returned from kmalloc has a kernel logical address.

------[11.1.5] Kernel virtual addresses

    Kernel virtual addresses are similar to logical addresses in that they are a
    mapping from a kernel-space address to a physical address. Kernel virtual
    addresses do not necessarily have the linear, one-to-one mapping to physical
    addresses that characterize the logical address space, however. All logical
    addresses are kernel virtual addresses, but many kernel virtual addresses
    are not logical addresses. For example, memory allocated by vmalloc has a
    virtual address (but no direct physical mapping). The kmap function
    (described later in this chapter) also returns virtual addresses. Virtual
    addresses are usually stored in pointer variables.


----[11.2] High and Low Memory

------[11.2.1] Low memory

    Memory for which logical addresses exist in kernel space. On almost every
    system you will likely encounter, all memory is low memory.

------[11.2.2] High memory

    Memory for which logical addresses do not exist, because it is beyond the
    address range set aside for kernel virtual addresses.


----[11.3] Page Tables

    On any modern system, the processor must have a mechanism for translating
    virtual addresses into its corresponding physical addresses. This mechanism
    is called a page table; it is essentially a multilevel tree-structured array
    containing virtual-to-physical mappings and a few associated flags. The
    Linux kernel maintains a set of page tables even on architectures that do
    not use such tables directly.


----[11.4] Virtual Memory Areas

    The virtual memory area (VMA) is the kernel data structure used to manage
    distinct regions of a process's address space. A VMA represents a
    homogeneous region in the virtual memory of a process: a contiguous range of
    virtual addresses that have thesame permission flags and are backed up by
    the same object (a file, say, or swapspace). It corresponds loosely to the
    concept of a "segment", although it is better described as "a memory object
    with its own properties." The memory map of a process is made up of (at
    least) the following areas:

        • An area for the program's executable code (often called text)
        • Multiple areas for data, including initialized data (that 
          which has an explicitly assigned value at the beginning of
          execution), uninitialized data (BSS), and the program stack
        • One area for each active memory mapping

    $ cat /proc/<pid/maps> # vmmap per pid
    $ cat /proc/self/maps  # caller proceses's vmmap


        00400000-00405000   r-xp   00000000 03:01 1596291     /bin/cat
           ^         ^       ^        ^      ^  ^   ^            ^
        va start  va end   perm     offset  major  inode       image
                          p=priv    (from    minor
                          s=shared  image
                                    start)


----[11.5] The mmap Device Operation

    Memory mapping is one of the most interesting features of modern Unix
    systems. Asfar as drivers are concerned, memory mapping can be implemented
    to provide user programs with direct access to device memory.

    The kernel can manage virtual addresses only at the level of page tables the
    mapped area must be a multiple of PAGE_SIZE and must live in physical memory
    starting at an address that is a multiple of PAGE_SIZE (usually 4096).

    Device driver developer must implement mmap interface himself for supporting
    mmap operations.

        $ cat /proc/<pid/maps> | grep /dev/mem
        $ cat /proc/iomem


----[11.6] Allocators

    Kernel'de belli başlı allocatorlar ile yapılıyor bellek işlemleri.  Biz
    malloc()'la falan bir bellek istediğimizde kernel gidiyor en uygun, en
    kopukluk olmayacak fiziksel bölgeyi sanal bellek alanına "map"liyor. Bu
    bölgelere ait bilgiler "struct page"lerde saklanıyor (free mi değil mi vs.).

    Bu yönetimi yapan farklı farklı allocator'lar geliştirilmiş; ve exploit
    edilecek sistemde hangisi varsa onun detayını bilmek elzemmiş (tıpkı
    userspace heap implementasyonları gibi).

------[11.6.1] Zoned page frame allocator (buddy allocator)

    alloc_pages() ve free_pages() çağrılarına bakan, 'buddy system algorithm'
    kullanan, genel bir allocator.

------[11.6.2] Slab allocators

    Buddy çok genel kalıyormuş, daha özelleştirilmiş algoritmalara ihtiyaç
    duyulmuş zamanla. Daha ince ayarlı allocator sistemi olarak slab'ler
    geliştirilmiş. Mesela 128B bellek istiyoruz, buddy'de mecbur PAGE_SIZE'lık
    alan ayrılırmış ama Slab'ler daha ufak ayırmalar yapabiliyor. Kısaca çoğu
    zaman Slab'le haşır neşir oluyoruz. Kernelde 3 farklı Slab gerçeklemesi var
    (sadece 1'i aktif):
    
    1- SLAB: Geleneksel ve eski, cache optimizasyonlarına odaklı,
             Debian hala bunu kullanıyormuş. UAF exploitleri SLUB'a
             göre daha kolay. İyi dökümante edilmiş.
    2- SLUB: 2007'den beri yeni standart bu, Ubuntu, CentOS, Android
             Bunu exploit etmenin ise 'slab aliasing' diye bir
             kolaylığı varmış: SLUB general kmemcache'lerde daha
             fazla obje saklıyor. İyi dökümante edilmemiş ???? TODO
             fakat anlaması SLAB'e göre daha kolaymış (SLAB'deki
             gibi "cache coloring", "full slab" takibi,
             internal/external slab yönetimi falan yokmuş).
    3- SLOB: Çok ufak hafızalı gömülü sistemler için tasarlanmış

    (Bunların her birine genel olarak "Slab" deniliyor)
    
    Sistemde hangisi aktif bakmak için:
    ----------------------------------------------------------------
    $ grep "CONFIG_SL.B=" /boot/config-$(uname -r)

    # ya da

    $ cat /proc/slabinfo  # eğer "size-XXX li cache'ler varsa SLAB
                          # "kmalloc-XXX li cache'ler varsa SLUB
    ----------------------------------------------------------------

    Ayrıca cache'ler var ve bunlara (küçük harfle) slab deniliyor.
    Kısaca bir slab bir veya birden çok sürekli page frame'i demek.


------[11.6.3] İsimlendirme
           
    SLAB: algoritma
    Slab: yöntemlerden biri (SLAB/SLUB/SLOB)
    slab: sürekli bellek alanı, PAGE_SIZE veya katları boyutunda
        

--------[11.6.3.1] Cache

    Kernel, tekrar tekrar aynı büyüklükte obje oluşturmaya meyilli olduğundan;
    Slab'lerin yönettiği cache mekanizmaları oluşturulmuş. Kısaca çeşitli
    boyutlarda pek çok cache var ve yeni oluşturulan obje hangisine en iyi
    oturuyorsa ona konuluyor.

    NOT: Bu cache'ler CPU cache'leri değil. Bunlar yine bellekte.

    Cache descriptor olan "struct kmem_cache":
        ----------------------------------------------------------------
        // include/linux/slab_def.h

        /*
         * Definitions unique to the original Linux SLAB allocator.
         */

        struct kmem_cache {
                struct array_cache __percpu *cpu_cache;
                unsigned int num;		/* # of objs per slab */

                /* order of pgs per slab (2^n) */
                unsigned int gfporder;

                struct kmem_cache *freelist_cache;
                unsigned int freelist_size;

                /* constructor func */
                void (*ctor)(void *obj);

                const char *name;
                int refcount;

        #ifdef CONFIG_KASAN
                struct kasan_cache kasan_info;
        #endif

                // GALİBA: holds list of empty/partial/full slabs
                struct kmem_cache_node *node[MAX_NUMNODES];

                // ...
        };
        ----------------------------------------------------------------


--------[11.6.3.2] slab

    Küçük harfle "slab", sürekli bellek alanı, PAGE_SIZE veya katları boyutunda
    demiştik.

    TODO Hey 5.8'de yok


--[12] Kernel'in bellek yönetimi 2 - Tanenbaum: Modern Operating Systems 2014 ch 3

----[12.1] Model 1: Memory abstraction yok

        Tüm programlar doğrudan fiziksel adreslere erişiyor. Tabii riskli şeyler
        ortaya çıkıyor (userspace program kerneli bozuyor falan). Aynı anda iki
        program çalışması için mimarlar taklalar atıyor. Eski bilgisayarlar
        böyleydi. Şu an embedded sistemlerde hala boyle olanlar var.


----[12.2] Model 2: Base ve limit register'ları ile memory abstraction

        Abstraction'dan kasıt, her programın ayrı bir adres uzayına sahip
        olduğunu düşünmesini sağlamak.

        İlk abstraction modeli, CPU'ya base ve limit adında iki register eklemek
        olmuş (CDC 6600). Her bellek erişimine base'deki değer ekleniyormuş ve
        erişimin limit'ten küçük olması gerekiyormuş. base register'inda o
        programın bellekteki fiziksel adresi tutuluyor, ve her bellek erişiminde
        base değeri adrese ekleniyormuş. limit'te de programın boyutu
        tutuluyormuş ve limit'ten dışarı erişimler engelleniyormuş.

        Intel 8088'de birden çok base registerı varmış ama hiç limit register'ı
        yokmuş, bu yüzden programlar adres uzaylarının dışına erişebiliyormuş.


----[12.3] Swapping

        Kullanılmayan programın belleğini diske kaydet, kullanılacağı zaman geri
        yükle.


----[12.4] Boş belleğin yönetimi

------[12.4.1] bitmap ile

    Eskiden bitmapler varmış. Belleğin bir yerinde duran bu bitmap, belirli
    boyuttaki chunk'ların dolu veya boş olduğunu tüm hafıza için tutuyormuş (1
    ve 0). Tabii yer kaplıyor ve kullanması yavaş.

------[12.4.2] linked list ile

    Sonra belleğin ayrı bir yerinde bir linked list ile boş-dolu belleklerin
    tutulması fikri varmış. Bitmap'e göre daha hızlı. Yeni bir bellek alınacağı
    zaman bu liste üzerinde arama yapılıyormuş; first fit, next fit, best fit,
    worst fit, quick fit gibi algoritmalar denenmiş.


----[12.5] Sanal bellek (virtual memory)

    Multiprocessing yönetim işi programcıya ait olup zorlaşmaya başlayınca,
    1961'de birisi her şeyi OS'in halledeceği sanal bellek fikrini ortaya atmış.
    Basitçe, her programın kendi adres uzayı var ve bu uzay "page"lere bölünmüş
    durumda. Bu page'lerin tekabül ettiği fiziksel olarak sürekli adresler var.
    Pagelerin tümünün aynı anda bellekte tutulmasına gerek yok; bellekte olmayan
    bir page'e erişilmeye çalışılınca "page fault handler" donanımsal yardım
    (MMU) ile ilgili page'i hafızaya yerleştiriyor.

    MMU'lar eskiden ayrı imiş şimdi CPU'ya gömülü.


------[12.5.1] Paging

--------[12.5.1.1] page

    sanal sayfa


--------[12.5.1.2] page frame

    fiziksel sayfa
            

--------[12.5.1.3] page table

    page ve page frame'leri eşleştiren tablo. Yeri: MMU ya da bellek.


--------[12.5.1.4] page table entry

    tablodaki girdiler


                              present/
                    refrncd?   absent
                    +-+^+-+-----+^+------------------------+
                    | | | | rwx | |   page frame number    |
                    +v+-+v+-----+-+------------------------+
           caching <-'  modified?
          disabled?
                        
                       Görsel: Örnek page table entry


--------[12.5.1.5] TLB (translation lookaside buffer) 

    Fiziksel-sanal bellek adres dönüşümü dar boğaz faktör olmaya başlayınca
    çözüm fikirleri çıkmış. Eşleştirme tablolarını ayrı registerlarda tutalım
    diyince maliyet çok yüksek; tamamen bellekte tutalım diyince de hız çok
    düşük oluyormuş.

    Bakmışlar ki programlar genelde sadece belirli page'lere erişiyor; demişler
    ki biz donanımda TLB diye ufak bir hafıza ayıralım, burada belli başlı
    page'lerin fiziksel karşılıklarını tutalım. Genelde bu tablolar 256 girdiden
    büyük olmazmış.

    TLB'ler MMU tarafından da yönetilebilirmiş, yazılımsal olarak da. Yazılımsal
    olarak yönetmek o kadar da yavaşlığa sebep olmuyormuş, hem de donanımsal
    maliyeti yok.

----------[12.5.1.5.1] Çalışması

    1) MMU'ya bir sanal page'in fiziksel karşılığı sorulunca:
    2) MMU, TLB'ye bakar:
        2.1) TLB'de varsa ve prot bitleri uygunsa: PAGE FRAME
                                                   VERİLİR
        2.2) TLB'de varsa ama prot bitleri uygunsuzsa: PROTECTION 
                                                       FAULT
    3) O page TLB'de yoksa:
        3.1) MMU, normalde yaptığı gibi işlemin bellekteki page
             table'ına bakar ve PAGE FRAME VERILIR
             3.1.1) Ve MMU o page table entry'yi BELLEKTEN TLB'YE 
                    ÇEKER (bu sırada TLB'dekini de geri bellekteki
                    page table'a yazar)

                

        +-------+--------------+----------+------------+------------+
        | Valid | Virtual page | Modified | Protection | Page Frame |
        +-------+--------------+----------+------------+------------+
        |   1   |      140     |    1     |    rw-     |     31     |
        +-------+--------------+----------+------------+------------+
        |   1   |       20     |    0     |    r-x     |     38     |
        +-------+--------------+----------+------------+------------+
        |   1   |      288     |    1     |    rwx     |     29     |
        +-------+--------------+----------+------------+------------+
        |   1   |       59     |    0     |    r--     |     10     |
        +-------+--------------+----------+------------+------------+
        |   1   |      814     |    1     |    r-x     |     75     |
        +-------+--------------+----------+------------+------------+
        |       |              |          |            |            |
        .       .              .          .            .            .

                            Görsel: Örnek bir tlb


--------[12.5.1.6] Soft miss

    page tlb'de yoksa ama işlemin belleğinde ise.


--------[12.5.1.7] hard miss

    page tlb'de de işlemin belleğinde de yok; diskte ise.


--------[12.5.1.8] page table walk
                
    page table hierarchy üzerinde entry arama.


--------[12.5.1.9] minor page fault

    page bellekte ama bizim işlemin değil, başka işlemin belleğinde.  map'lemek
    yeterli.


--------[12.5.1.10] major page fault

    page bellekte değil diskte. mecbur oradan okuyacağız.


--------[12.5.1.11] segmentation fault

    program geçersiz bir belleğe erişmeye çalıştı; sonlandırıldı.


--------[12.5.1.12] multilevel page tables

    Sanal adres space'leri büyüdükçe böyle bir yapı kurmak gerekmiş.  Mesela 32
    bit bir adresin ilk 10 bit'i PT1, ikinci 10 biti PT2, son 12 biti ise offset
    olarak kullılarak birkaç aşamada asıl entry'ye erişiliyor.


--------[12.5.1.13] inverted page table

    Normalde page table'larda "sanal adresin fiziksel karşılığı ne?" sorusunun
    cevabı varken, bu yöntemde tam tersi, "fiziksel adresin sanal karşılığı ne?"
    sorusu üzerine bir tablo var.  Dolayısıyla fiziksel adresin gerçek boyutuna
    bağlı bir page table ortaya çıkıyor ve boyutu da haliye çok büyük olmuyor.
    Ama bu sefer te sanaldan gerçeğe adres dönüşümü için tüm tabloyu tek tek
    okumak gerekiyormuş falan ve TLB'de hash table tutarak hızlandırmışlar
    falan.

    64 bit sistemlerde yaygın kullanılıyormuş bu yaklaşım. Hala mı?


--------[12.5.1.14] Page replacement algoritmaları

    Page fault olunca hangi entry'yi dışarı atsak da yenisini alsak?  Bazı
    yaklaşımlar şöyle:

        Algorithm                       Comment
        ----------------------------------------------------------------
        Optimal                         Not implementable
        NRU (Not Recently Used)         Very crude approximation of LRU
        FIFO (First-In, First-Out)      Might throw out important pages
        Second chance                   Big improvement over FIFO
        Clock                           Realistic
        LRU (Least Recently Used)       Excllnt,hard to implement exctly
        NFU (Not Frequently Used)       Crude approximation to LRU
        Aging                           Efficient, approximates LRU well
        Working set                     Somewhat expensive to implement
        WSClock                         Good efficient algorithm


--------[12.5.1.15] İdeal page size

    Bugünlerde 4K. 512B - 64K arası değerler kullanılmış zamanında.


--------[12.5.1.16] Instruction ve data space'leri ayrı tutmak

    Böyle bir yapkaşim da olmuş. Galiba çok eski...


--------[12.5.1.17] Shared pages ve COW (copy on write)

    Multiprogramming sistemlerde yerden tasarruf için ortak page'leri ortak
    kullandırmak iyi bir yaklaşım. UNIX'te fork() gerçekleşince, çocuk işleme de
    bir page table veriliyormuş ve bu tablo annesininkiyle aynı page'lere işaret
    ediyormuş. Ama tüm girdiler READ ONLY. Bu RO page'lerden birine yazılmak
    istendiği zaman gerçek page fault oluyormuş ve bu page'in gerçek bir kopyası
    oluşturuluyormuş, yani copy on write.


--------[12.5.1.18] Shared libraries

    Büyük boyutlu kütüphanelerdeki sık kullanılan fonksiyonları her exe'ye
    eklemek yerine paylaşımlı kütüphanelerde tutup çalışma sırasında oradan
    çekme fikri.

    Eğer başka bir program shared lib'i belleğe yüklediyse yeni program doğrudan
    oradan kullanır, yeniden yükleme yapmaz; ki shared lib'deki asıl amaç da
    budur. Ayrıca bir shared lib belleğe tek seferde yüklenmez, ihtiyaç
    duyuldukça page page yüklenir. Eğer PIE (position-independent code) ile
    derlenmezse her program için lib'in page'leri ayrı yere kopyalanır, shared
    olmasının bir manası kalmaz.


--------[12.5.1.19] Mapped files

    İşlemler istedikleri dosyalara write/read ile erişmek yerine, onları
    belleklerine "map"leyebilirler. Bu sayede gerektikçe dosya page size
    büyüklüğünde parçalar halinde belleğe yüklenir ve bir char array gibi
    erişilebilir. Yazma yapıldığı zaman değişikliğin yansıması için unmap
    yapması ya da işlemin sonlanması gerekiyor.
    
    Shared memory üzerinden IPC yapmak bu şekilde oluyor.

    Aslında shared lib'ler mapped files'ın ufak bir alt kümesi.


------[12.5.2] Adım adım paging

    İşletim sistemi 4 yerde paging alakalı iş yapar: 

        1 İşlem oluşturma anında
        
            Data ve text sectionları büyüklüklerine bakarak bellekte
            page table oluşturulur. Swap-out edilebilecek page'ler için
            swap area'da da yer oluşturulur. Programın data ve text
            sectionları swap area'ya da yazılır ya da doğrudan exe
            üzerinden map'lenir; ki page fault alındıkça oralardan
            page-in yapılırlar.

        2 İşlem çalıştırmaya başlarken

            Bir işlem çalışmaya başlamadan önce MMU bu yeni işlem için
            re-set'lenir ve TLB de temizlenir. Yeni işlemin page table'ı
            güncel page table olarak seçilir (register(lara) tablonun
            tamamını ya da tablo pointer'ını yazarak). Ve bazen de
            işlemin page'lerinin belirli bir kısmı ya da tamamı önceden
            belleğe alınır ki ilerde daha az page fault olsun.

        3 Page fault anında

            İşletim sistemi hangi sanal adres fault'a sebep oldu diye 
            ilgili register'a bakar. Bu bilgi ile de diskten o page'i
            boş bir page frame'e yükler. Yer yoksa bellekten bir page
            frame'i diske geri yazar. Sonra PC'yi hata veren
            instruction'a ayarlar ve işlem çalışmaya devam eder.

        4 İşlem sonlandırma anında

            İşletim sistemi, işlemin page table'ını, page'lerini ve
            diskteki depolanmış page'lerini salıverir. Eğer bu
            page'lerden shared olanlar varsa, kullana işlemler sonlanana
            kadar onları tutar.


------[12.5.3] Adım adım page fault handling

    1 Donanımsal trap oluşturulur, PC stack'e kaydedilir, o anki
      instructionun durumu özel registerlara kaydedilir

      1.1 Instruction backup: O anki instructionun durumunu kaydetmek o
          kadar da kolay değil, bazen donanımda özel registerlar
          bulunduruluyormuş state'leri tutmak için.

    2 GPR'lar ve diğer bazı şeyler bir asm routine tarafından
      kaydedilir (stack'e galiba). Sonra bu routine kernel'i bir 
      procedure (fonksiyon) olarak çağırır.

    3 OS hangi adresten oldu diye aramaya başlar. Genelde bir
      registerda o adres tutulur ama yoksa da hata veren
      insturiction'u tekrar çalıştırıp adresi yakalamak zorunda.

    4 Adres öğrenilince adres doğru mu ve protection uygun mu diye
      bakar. Değilse işleme signal yollar veya öldürür. 

    5 Eğer adreste ve prot bitlerinde sorun yoksa boş bir page frame
      var mı diye bakılır, yoksa page replacement algoritması
      devreye girer ve bir page seçer. Bu page "dirty" ise yani
      yazılmış ama diskteki (mmap'ed file ise) ya da swaptaki
      (anonymous page ise) aslı güncellenmemişse ilk olarak bu
      temizlenir yani aslı güncellenir. Bu temizleme arka planda
      yapılabileceğinden bu sırada "context switch" olur ve diğer
      işlemler çalışır. Bu sırada ilgili frame "busy" olarak
      işaretlidir koruma amaçlı.

    5 Page frame temiz ise (ya da temizlendiyse), işletim sistemi
      diskteki page'i, bellekteki page frame'e okumak üzere talimat
      verir ve bu arka planda yürütülür; CPU başka işlemlere hizmet
      verir.

    6 Disk interrupt'ı page'in geldiğini haber edince page table
      güncellenir ve page frame normal olarak işaretlenir.

    7 Faulta sebep olan instruction hata anındaki durumuna getirilir
      ve PC ona işaret ettirilir.

    8 Faulta sebep olan işlem schedule edilir ve 2. adımda procedure
      olarak çağırılmış işletim sistemi, asm routine'e return yapar.

    9 Asm routine GPR'ları ve diğer bilgileri geri yükler ve
      userspace'e return eder, program çalışmaya devam eder.


------[12.5.4] Diske page yedekleme

    Hep dedik yedeklenir swapa atılır falan ama bunun aslı ne? Şöyle ki birkaç
    şekilde yapılabiliyor bu.

    Unix'te swap diye ayrı bir partition ya da disk oluyor. Burada bir fs yok ve
    doğrudan diskin blok numarasıyla erişim yapılıyor yani hızlı.

    Eğer swap diye bir partition yoksa, Windows'ta da yapıldığı gibi büyük
    bir/birkaç dosya oluşturuluyor ve dosya sistemi üzerinden bu dosyalara yazma
    okuma yapılarak bunlar swap partition gibi kullanıliyor.

    İki swaplama yöntemi varmış:

        1 Program başlatılırken tüm imajı swap'a yazmak ve ihtiyaç
          oldukça oradan page-in yapmak

        2 Program başlatılırken tüm imajı belleğe almak ve ihtiyaç
          oldukça oraya page-out yapmak

    Sanırım linux'umda ikinci yöntem kullanılıyor zira swap %0 dolu.


------[12.5.5] Segmentation

    Paging dedik ama, bu paging belleği 0-0xfffffffffff... arası tek boyutlu bir
    yapı olarak değerlendiriyor. Dinamik büyüyen section'lar olunca ve bunlar
    çok olunca overflow yönetimi zorlaşıyormuş. Sonuçta ne kadar page olursa
    olsun bu sectionlar 0-0xfffffff... arasında birbiriyle bağlantılı alanlara
    yerleştiriliyor.

    İşte bunu çözmek için "segmentleyelim" demişler. Her section için bir
    segment olduğunu düşünün ve bu segmentler ayrı ayrı address space'lere
    sahip, dolayısıyla birbirlerini sanal adreste ezemiyorlar.

    Paging OS tarafından yönetiliyordu, segmentation ise programcı tarafından
    kontrol edilmesi gereken bir şeymiş.

    Avantajları şu şekilde:

        1   Dinamik büyüyen sectionlar ayrı segmentlerde tutulunca ayrı
            sanal adres uzayları olduğu için birbirini ezme durumu
            olmuyor.

        2   Tüm segmentler 0x0 adresinden başladığı için linkleme
            aşaması çok kolaylaşıyor. Recompilation yapılacağı zaman
            sadece o segmentteki section derlense yetiyor; diğer
            sectionlardaki adreslerle bağımlılık yok çünkü.

        3   Sadece paging yapan sistemlere göre işlemler arası shared
            lib paylaşımı daha kolay oluyormuş.

        4   Protection bitleri page bazlı değil, segment bazlı
            ayarlanabildiğinden section yönetimi daha kolay.

            
--------[12.5.5.1] x86-64: Segmentation artık yok

    Geriye uyumluluk için kısmen yer alsa da piyasada çok tutulmayınca
    segmentation özelliğini kaldırmışlar.

    "None of the developers of any UNIX or Windows system wanted to change their
    memory model to something that was x86 specific because it would break
    portability to other platforms. Since the software was not using the
    feature, Intel got tired of wasting chip area to support it and removed it
    from the 64-bit CPUs."


--------[12.5.5.2] x86: Segmentleri page'lemek

    Segmentlerin boyutu büyük olunca bellekte tutmak zor olacağı için
    (MULTICS'den özenerek) segmentleri page'leyelim demişler.

    16K segment varmış ve her biri 1 milyar tane 32-bitlik word tutuyormuş. İki
    önemle tablo ile segmentation yönetimi yapılıyor.


----------[12.5.5.2.1] LDT (local descriptor table)
        
    Her programın ayrı bir LDT'si var ve bu tabloda programın code, data, stack
    vs. segmentleri tanımlı. (Herhalde ayrı bir donanım yoktur bunun için.)
                

----------[12.5.5.2.2] GDT (global descriptor table)

    Sistem segmentleri tanımlıymış, kernelin segmentleri de burayada
    tanımlıymış. 1 tane var ve tüm programlar bunu paylaşıyor.
            
                
----------[12.5.5.2.3] segment:offset -> fiziksel adres dönüşümü

    Doğrusu anlamadım. Segment registerları ile bir adres alınıyor sonra birkaç
    hesap yapılıyor, multilevel bir paging ile (page directory -> page table ->
    page frame) adres alınıyor. TLB'ler de pagedir:pagetable->pageframe
    dönüşümleri tutuluyor.

    6 tane (16-bit ?) segment registerı varmış ve ilk ikisi dışındakiler
    önemsizmiş:

        CS  Code segment
        DS  Data segment
        SS  Stack segment
        ES  Extra segment (programcı için)
        FS  Özel amacı yok
        GS  Özel amacı yok


--[13] Random notes to put somewhere in the note

----[13.1] KASLR -> KAISER -> PTI

    KASLR (Kernel Address Space Layout Randomization) is for the most part
    deprecated and replaced by KAISER (Kernel Address Isolation to have
    Side-channels Efficiently Removed) which in turn is deprecated and replaced
    by KPTI (Kernel Page-Table Isolation). These three "K-steps" are all part of
    "Kernel Hardening".


----[13.2] Spinlock

    In software engineering, a spinlock is a lock which causes a thread trying
    to acquire it to simply wait in a loop while repeatedly checking if the lock
    is available. Since the thread remains active but is not performing a useful
    task, the use of such a lock is a kind of busy waiting.


--[14] Notes from pwn.college kernel module

    'hlt', 'in' and 'out' insturictions require kernel privileges.

    cr3 register controls the page table used to translate virtual addresses
    to physical addresses. Accessed using 'mov' instruction.

    MSR_LSTAR register (model-specific register, long syscall target address
    register); defines where the 'syscall' instruction jumps to (in kernel).
    Accessed using 'wrmsr' and 'rdmsr' privileged instructions.


----[14.1] Rings

    VM guest shouldn't  be able to have unlimited access to the host's physical
    hardware.

    Early 2000's solution: force the VM kernel into ring 1.
    Drawback             : Cost of emulating ring-0 tasks of the vm

    Modern solution      : Ring -1; hypervisor mode. Able to intercept
                           sensitive ring 0 actions done by guests and
                           handle them in the host OS.


----[14.2] Different types of OS models

    1. Monolithic kernel: A single, unified binary handling all tasks.
                          Linux, FreeBSD.

    2. Microkernel: A tiny core binary provides IPC and barebone
                    interactions with the hardware. Only that core
                    binary runs at ring 0; all other drivers are
                    normal-ish userspace programs with slightly special
                    privileges. Slow but usable for security critical
                    situations.
                    Minux, seL4

    3. Hybrid kernel: Micrekernel features combined with a monolithic
                      component.
                      Windows(NT), MacOS


----[14.3] How kernel handles syscalls

    1. At bootup, in ring 0, the kernel sets 'MSR_LSTAR' register to
       point to the syscall handler routine (handle_syscall ?)

    2. When a userspace (ring 3) process wants to intract w/ the kernel,
       it calls 'syscall' instruction. In 'syscall':
       2.1 Privilege level switches to ring-0
       2.2 Control flow jumps to value of 'MSR_LSTAR'
       2.3 Return address saved to 'rcx', not stack for security reasons
    
    3. Whet kernel is ready to return to userspace, it calls 'sysret'
       instruction.
       2.1 Privilege level swithes back to ring 3
       2.2 control flow jumps to the value of 'rcx'


----[14.4] Kernel memory vs userspace memory

    Kernel has it's own virtual memory space, but in high addresses.

    Syscalls don't switch the virtual memory mapping, but kernel memory is only
    accessible from ring 0 (what dat means???)

        $ cat /proc/self/maps
        .
        .
        .
        7fd97c9d2000-7fd97c9d3000 rw-p 0002d000 08:05 1181832   /usr/lib/...
        7fd97c9d3000-7fd97c9d4000 rw-p 00000000 00:00 0 
        7ffd1f0f1000-7ffd1f112000 rw-p 00000000 00:00 0         [stack]
        7ffd1f18c000-7ffd1f18f000 r--p 00000000 00:00 0         [vvar]
        7ffd1f18f000-7ffd1f190000 r-xp 00000000 00:00 0         [vdso]
        ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall]

        vsyscall is the only mapped kernel memory in userspace; which used
        to be there to make syscalls faster but not used often nowadays. BTW
        linux-hardened doesn't show (or doesn't have) that mapping. This is
        from ubuntu.


----[14.5] Possible kernel attack vectors
        
    1. Remote (network etc.). Was popular around '95s. Rare nowadays.
    2. From userspace. Sandbox escaping etc.
    3. Via devices. USB device pwning USB driver etc.


----[14.6] Kernel modules

    Are libraries being loaded into the kernel.

------[14.6.1] Ways to interact w/ kernel modules

    1. System calls
    2. Interrupts
    3. Files (/dev/sda etc.)
       3.1 Via read() and write()
       3.2 Via ioctl()

------[14.6.2] Syscall hooking

    Historically, kernel modules could add system call entries via modifying the
    system call table. This is now explicitly unsupported in modern kernels.

------[14.6.3] Interrupt hooking

    A module could register an interrupt handler by using "LIDT" and "LGDT"
    instructions and be triggered by, say, an 'int 42' instruction.

    Useful one-byte interrupt instructions to hook:

        int3 (0xcc): normally causes a SIGTRAP; used by gdb for
                     breakpointing
        int1 (0xf1): normally used for hardware debugging

    A module can also hook the Invalid Opcode Exception interrupt to implement
    custom instructions in software.

------[14.6.4] Interation w/ modules via files

    - /dev; mostly traditional devices have files here
    - /proc; driver files about running processes (?)
    - /sys; non-process information interface w/ the kernel

    A module can register a file in one of the above locations.
    Userspace can open() that file to interact w/ the module.


--------[14.6.4.1] read() and write()

    Useful for streaming data.

    Kernel side provides:
        
        static ssize_t device_read(struct file *filp, char *buf,
                                       size_t len, loff_t *off);
        static ssize_t device_write(struct file *filp,
                            char *buf, size_t len, loff_t *off);

    Userspace side uses:
    
        fd = open("/dev/mydevice", 0);
        read(fd, buffer, 128);



--------[14.6.4.2] ioctl()
                
    Input/Output control provides a much more flexible interface. Useful for
    setting and querying not-stream data (i.e., webcam resolution settings).

    Kernel side provides:

        static long device_ioctl(struct file *filp,
             unsigned int ioctl_num, unsigned long ioctl_param);

    Userspace side uses:

        int fd = open("/dev/mydevice", 0);
        ioctl(fd, COMMAND_CODE, &custom_data_structure);


    That &custom_data_structure thing causes lots of vulnerabilities!


--------[14.6.4.3] Kernel Race Conditions

    They are always prone to multi-threading!
     - What happens if two devices (/dev/mydev) open simultaneously?

    They could disappear or swap resources mid-execution!
     - What happens if module.ko is removed while /proc/mydev is open?

    Race conditions are huge problems plaguing kernels!


--------[14.6.4.4] On credentials

    The credentials are supposed to be immutable (i.e., they can be cached
    elsewhere, and shouldn't be updated in place).  Instead, they can be
    replaced with fresh ones (via commit_creds()).


--[15] Kernelde Güvenlik

----[15.1] SELinux

    Security-Enhanced Linux was developed by National Security Agency (NSA)
    using Linux Security Modules (LSM).

    There are two modes of SELinux

        permissive - permission denials are logged but not enforced
        enforcing - permission denials are logged and enforced

    In Android the default mode of SELinux is enforcing and even if we get root,
    we are subjected to SELinux rules.

        generic_x86_64:/ $ getenforce
        Enforcing

    So, we need to disable SELinux as well.

------[15.1.1] Bypassing SELinux

    selinux_enforcing is a global variable which dictates whether SELinux is
    enforced or not. If we can figure out where selinux_enforcing is in memory
    and set it to NULL, then we can disable SELinux globally and now SELinux
    will be in permissive mode instead of enforcing mode.

----[15.2] SecComp

    SecComp stands for Secure Computing mode and is a Linux kernel feature that
    allows to filter system calls. When enabled, the process can only make four
    system calls read(), write(), exit(), and sigreturn().

    When running the exploit from adb shell we are not subjected to seccomp.
    However, if we bundle the exploit in an Android application, we would be
    subjected to seccomp.


            
--[16] Misc

----[16.1] UML (user mode linux)

    "uml": We could configure the kernel to run as User Mode Linux.  Running a
    UML kernel requires no privileges. The kernel just runs a user space
    process. UML is pretty cool, but sadly, it doesn't support KASAN, therefore
    the chances of finding a memory corruption bug are reduced.  Finally, UML is
    a pretty magic special environment - bugs found in UML may not be relevant
    on real environments.  Interestingly, UML is used by Android network_tests
    framework.

----[16.2] Linux insides kalinan yer:
    
    https://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-3.html

----[16.3] rawsploit: libc çok büyük gelince
    
    https://github.com/GrosQuildu/grosquildu.github.io/blob/adee55d3b9930fe291b50108df228780a0978f4e/assets/other/raw_sploit.h


----[16.4] AMD64 Kernel calling conventions

    Userspace'den tek farkı var.

    Userspace x64   : rdi, rsi, rdx, rcx, r8, r9, stack
    Kernelspace x64 : rdi, rsi, rdx, r10, r8, r9, stack


--[17] Fuzzing

    https://blog.cloudflare.com/a-gentle-introduction-to-linux-kernel-fuzzing/


--[18] Android SDK emulator kullanımı

----[18.1] Start emulator

    emulator -no-window -show-kernel -no-snapshot -wipe-data \
            -avd CVE-2019-2215 \
            -kernel out/kasan/dist/bzImage -qemu -s -S

----[18.2] Start gdb
    
    gdb -quiet out/kasan/dist/vmlinux -ex 'target remote :1234'

----[18.3] Set cpu cores to 1
        
    For better GDB debugging and tracing support, it's recommended to set the
    number of CPU cores to 1. 
        In ~/.android/avd/CVE-2019-2215.avd/config.ini:
            hw.cpu.ncore = 1

--[19] Rastgele Exploitation Notları

----[19.1] Data-only attacks

    Arbitrary Read Write primitives are also called as data only attacks.  Where
    we do not hijack the execution flow of the CPU and just corrupt targeted
    data structures to achieve privilege escalation.

----[19.2] addr_limit on arm64

    Vitaly Nikolenko (@vnik5287) pointed out that in arm64 there is a check in
    do_page_fault function which will crash the process if the addr_limit is set
    to 0xFFFFFFFFFFFFFFFF. So set it to 0xFFFFFFFFFFFFFFFE.

----[19.3] DiShen's UAF exploitation gadget: "struct iovec"

    iovec is a data structure used for vectored I/O a.k.a scatter gather.  It's
    used to read a big buffer and scatter it to smaller buffers and vice versa.
                                                                      
                                                                      
                  +------------------------------------+              
                  |                                    |              
                  |                                    |              
                  |                                    |<---------+   
                  |         big kernel buffer          |          |   
                  |                                    |<------+  |   
                  |                                    |       |  |   
                  |                                    |<---+  |  |   
                  |                                    |    |  |  |   
                  +------------------------------------+    |  |  |   
                         ^                                  |  |  |   
                         |                                  |  |  |   
         KERNEL          v                                  |  |  |   
         SPACE     +------------------+                     |  |  |   
         - - - - - |readv() & writev()| - - - - - - - - - - - - - - - -
         USER      +------------------+                     |  |  |   
         SPACE           ^                                  |  |  |   
                         |                                  |  |  |   
                         v                                  |  |  |   
                  +--------------+                          |  |  |   
                  | +----------+ |           +-----------+  |  |  |   
                  | | iov_base |-+---------->| user_buf1 |<-+  |  |   
                  | +----------+ |           +-----------+     |  |   
                  | | iov_len  | |                             |  |   
                  | +----------+ |           +-----------+     |  |   
                  | | iov_base |-+---------->| user_buf2 |<----+  |   
                  | +----------+ |           +-----------+        |   
                  | | iov_len  | |                                |   
                  | +----------+ |           +-----------+        |   
                  | | iov_base |-+---------->| user_buf3 |<-------+   
                  | +----------+ |           +-----------+            
                  | | iov_len  | |                                    
                  | +----------+ |                                    
                  +--------------+                                    

        --------------------------------------------------------------------
        // include/uapi/linux/uio.h.

        struct iovec
        {
            void __user *iov_base;
            __kernel_size_t iov_len;
        };
        --------------------------------------------------------------------

    Advantages of struct iovec:
        - small in size, on x64 bit system it's size is 0x10 bytes
        - we can control all the members iov_base and iov_len
        - we can stack them together to control desired kmalloc cache
        - it has a pointer to buffer and length of the buffer, which is a
          great target for corruption

    Issues with struct iovec:
        One of the main issue with struct iovec is that they are short lived.
        They are allocated by system calls when they are working with the
        buffers and immediately freed when they return to user mode.

    How do we make iovec structure stay in kernel before we trigger the bug?
        One way is to use system calls like readv, writev on a pipe file
        descriptor because it can block if the pipe is full or empty.

        pipe is an unidirectional data channel that can be used for interprocess
        communication. The blocking feature of pipe gives us significant time
        window to corrupt iovec structure in kernel space.

        In the same manner we can use recvmsg system call to block by passing
        MSG_WAITALL as the flag parameter.


------[19.3.1] How to pwn with this?

    I'm not sure. Gotta watch the video. It involves readv, writev, readmsg etc.
    syscalls.


----[19.4] Always winning the races w/ userfaultfd

    Userfaultfd is a syscall allowing userspace programs to handle pagefaults.
    Not sure about the real purpose of this; but this is extremely useful when
    it comes to race conditions; since it allows you to "pause" the kernel
    execution on certain triggers.

    Assume that there are two kfree paths on the kernel code. You want to get a
    double free.


        /* path 1 */
        if (copy_from_user((void*)&tmp->value, (void*)arg,
                                        sizeof(unsigned long))) {
          head = tmp->fd;
          kfree(tmp);
          return -EINVAL;
        }
        
        /* stuff here */

        /* path 2 */
        if (copy_from_user((void*)&tmp->value, (void*)arg,
                                        sizeof(unsigned long))) {
          head = tmp->fd;
          kfree(tmp);
          return -EINVAL;
        }

    Since copy_from_user takes its data from userspace, it means it accesses
    userspace pages. If a pagefault occurs while accesing these userspace pages,
    it's users decision to leave the handling to kernelspace (as normally
    happens) or handle it in userspace using userfaulttfd syscall.  If user
    (hacker in this scheme) writes it's own pagefault handler, he/she can freely
    slow down (or basically, stop) the execution speed until he/she wishes to
    resume it again.

    The only condition here is a pagefault to be happen. If we map an absurd
    page which is 99% out of page directory, it's inevitable the kernel will
    lazy load that page while calling copy_from_user and a pagefault will
    happen. When it happens, haxor freezes that thread and in another thread,
    he/she triggers the second kfree path somehow and double-free!  (yeah the
    exapmle above may not be the best descriptive example but it's enough if you
    got the idea). Also, for exploiting this, some other useful kernel data
    structures probably needs to be involved.

    How to use this exactly? You can checkout some writeups; they mostly follow
    the userfaultfd(2) man page but some critical points are different. You'll
    probably copy-paste the code w/o understanding it totally; which is fine in
    kernel land.

    https://web.archive.org/web/20201205053538/https://blog.lizzie.io/using-userfaultfd.html
    https://smallkirby.hatenablog.com/entry/2020/08/09/085028


----[19.5] seq_operations'un ilk pointer'ını ezmenin yeterli oluşu

            struct seq_operations {
                            void * (*start) (...);
                            void (*stop) (...);
                            void * (*next) (...);
                            int (*show) (...);
            };

    kstack sorusunda show'u ezmemiş gerekmişti. start()'ı rastgele bir değerle
    ezmiştik ama sorun olmamıştı, read(fd_seq_operations) yapınca sadece show()
    tetiklenmişti.

    Bu soruda ise sadece start()'ı ezmek yetti. Hatta diğer ptr'ları rastgele
    değerlerle ezmemize rağmen read(fd_seq_operations) yapınca sadece start()
    tetiklenmiş oldu. Bilmem neden.


----[19.6] Stack pivot gadget'indeki adresin son 3 byte'ı 0'dan farklı olmalı

    Uzun bir süre

            mov esp, 0xf6000000; ret;

    gadgeti çalıştırılmaya çalışıldı ama double fault alınıyordu. Daha doğrusu
    bu gadget çalışıyor ve esp ilgili adrese zıplatılıyordu ama bir sonraki
    gadget çalışacağı zaman double fault (yani fault handling sırasında fault)
    tezahür ediyordu.

    Sonra

            mov esp, 0xf6fffffa; ret;

    kullanınca düzeldi. Sebebi şuymuş: PAGE_SIZE yani 0x1000'in tam katları olan
    adreslere pivotin yapınca, rop sırasında bir sonraki page'e erişilmeye
    çalışılınca page fault oluyormuş ve nedense patlıyormuş. Böyle küsüratlı bir
    adres seçince ise sorun olmadı. Nedeni tam anlaşılamasa da böyle olması
    gerekiyormuş.


----[19.7] mov rdi, rax  --> mov edi, eax 'a dönüşüyor ve patlatıyor

    Bu gadget için iki aday mevcuttu:

            0xffffffff81177417: mov rdi, rax; pop rbx; mov rax, rdi; pop r12; pop rbp; ret;
            0xffffffff810703bb: mov rdi, rax; xor eax, eax; cmp rdi, 0x81; je 0x2703cb; pop rbp; ret;

    Uzun bir süre ilki kullanılmaya çalışıldı. Ve uzun bir süre exploitin
    çalışmamasına sebep oldu. Anlamak da zordu çünkü gdb ile bakınca exploit
    normalde sorun olan yerden daha evvel patlıyor gibi gözüküyordu. Tam patlama
    anında kernel crash dump'ı ile gdb context'i karşılaştırınca senkronizasyon
    hatası olduğu fark edildi. Crash dump'ına göre çökmeye sebep olan asıl
    instruction, gdb'deki rip'in birkaç sonrası idi. Her neyse, aday
    gadget'lardan ilkindeki:

            mov rdi, rax

    x/32xi ile bakınca "mov rdi, rax" olarak gözüküyor fakat çalışma sırasında
    bir şekilde

            mov edi, eax

    'a dönüşüyor. Ayrıca bu mov sırasında edi'ye taşınırken rdi'ın 8:16 bitleri
    sıfırlanıyormuş. Sonra da pointer aritmetiğinde hata oluyor ve crash!

    Bu dönüşüm neden oluyor anlayamasak da "mov edi, eax"ın dokunulmayan üst
    bitleri sıfırlaması beklenen bir etkiymiş (ve hatta stack pivotumuz da bu
    yüzden doğru çalışabiliyor).


----[19.8] swapgs_restore_regs_and_return_to_usermode yerine kullanılabilecekler

    Eski kernel'larda bu sembol bulunmuyor. Bunun yerine muadillerimiz neyse ki
    mevcut.

    Kısaca, bu sembol iki işi bir arada yapıyordu: swapgs ve iretq. Biz bu iki
    işi ard arda yapacağız, bu kadar. Kullanılabilecekler ve kullanılamayacaklar
    şöyle:

        1. Müstakil "swapgs" ve "iretq" gadgetları vmlinux'tan kullanılabilir.

        2. swapgs için kallsyms'te de yer alan

                native_swapgs

           sembolü kullanılabilir, fakat

                nmi_swapgs

           kullanılamaz (trap'e sepeb oluyor)

        3. iretq için hem

                native_irq_return_iret

           hem de

                native_iret

           sembolleri kullanılabilir.

    Belki başka semboller de kullanılabiliyordur. Bunlar tecrübe edildi.


[*] Exploitation cheatsheet

    cpio -id < initramfs        # extract initramfs
    cpio -id < rootfs.cpio      # extract rootfs.cpio
    lsinitrd initramfs          # list contents w/o extracting
    linux/scripts/extract-vmlinux <kernel image> >vmlinux  # extract vmlinux
                                                             from bzImage or
                                                             vmlinuz


vim:set ts=8 sw=4 sts=4 et cc=80 tw=80:
